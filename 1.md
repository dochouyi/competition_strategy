修改这个代码
每5分钟计算一次matching_pairs = self.selector.select_pairs(close_prices_5m),（目前是1分钟计算一次，用的是5m的数据，这5m内算的结果本质上都一样）

设置一个数据结构，来保存每一个matching_pair的交易信息（属性较多，随着后续交易不断更新）

每一次会产生多个matching_pair，也就是matching_pairs，每一个matching_pair都要处理

matching_pair包含产生时候的时间戳，a（币名称）,b（比名称）,beta。

设置一个保存所有产生的matching_pair的大列表，将所有新产生的matching_pair一个个添加进去。也就是每5分钟必然会添加几个进去。

对于每一个a,b,beta（也就是一个matching_pair），都要经过实时1m数据的_try_open()操作，如果没有在20个5m内成交，则这个matching_pair的是否成交属性为False。

如果在指定时间内入场（在20个5m内），则记录入场时间戳，记录入场时候的a,b价格（1m）以及5m布林带上中下轨的数值（spread对应的值）,记录入场方向。(这些信息都记录在matching_pair的数据结构里面)

当入场之后，每一分钟都对这个入场进行_try_close()看是否满足出场条件，如果在100个5m内没有出场，则最后强制出场；

默认出场条件是spread值（1m）达到5m布林带中轨的数值（大于或者等于），出场价格严格按照1m的数据来。

在出场后，记录出场时候的时间戳，a,b价格（1m），5m布林带中轨值（spread对应的值），以及入场期间的最大回撤，还有计算收益率（计算收益率的时候不考虑手续费以及滑点）,记录出场原因（包括回到中轨和强制出场两种情况）。完成出场的信息也添加到matching_pair中。

将matching_pair以及相关属性信息全部实时保存到sqlite数据库中进行保存和实时处理

python数据库方面采用orm实现


配对对冲策略简介

假设币对之间存在相关性，尤其是相似性，选择合适的币对进行关注，目前是从binance单个交易所获取前30大市值币种进行币对对冲。
构建的量化系统实时计算过去一段时间币对之间的相关性，筛选出相关性排名靠前的币对，通过数学手段滤除不相关对，然后计算币对间线性比例关系，然后构建布林带策略进行进场和出场。

这个策略能够避免市场整体的上涨或者下跌带来的冲击，因此较为稳健。具体策略涉及众多工程上的一些技巧。


